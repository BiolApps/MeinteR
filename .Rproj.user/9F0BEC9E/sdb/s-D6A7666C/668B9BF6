{
    "contents" : "########################################################################################################################\n## Package    : MeinteR\n## File       : dmsAltSplice.R\n## Functions  : findAltSpliceDMSOverlaps (exported)\n##            : findCanonicalDMSOverlaps (exported)\n##\n## Updated    : 04-11-2015\n##\n## Title      : Alternative splicing events and canonical exons overlapping differentially methylated sites. \n########################################################################################################################\n\n\n\n#' Find alternative splicing events overlapping differentially methylated sites\n#'\n#' Matching differentially methylated sites to various types of alternative splicing events \n#' that result in more than a single transcript from the same gene.\n#'\n#' @param bed.file.name   A bed file (full path) with the following fields: chrom, chromStart, chromEnd, strand, score\n#' @param bed.data  If data already loaded use this parameter instead of \\code{bed.file.name}\n#' @param known.alt.splice (optional) Full local path to the UCSC knownalt table. If the table is not available locally then the script will fetch it from UCSC.\n#' @param group.name (optional) Name of the group.\n#' @param group.thr Grouping threshold. Two groups will be created of according to the differential methylation level. Group1 Delta Beta>=group.thr and Group2 Delta Beta<group.thr\n#' @return Group1 overlapping segments A dataframe with high DMR (>=group.thr) that overlap with the altsplice events (hg19)\n#' @return Group2 overlapping segments A dataframe with low DMR (<group.thr) that overlap with the altsplice events (hg19)\n#' @return Frequency Table A summary table with the frequency of each type in group1, group2 and reference\n#' @return A stacked bar chart object\n#' @return pvalue Statistical significance of group1, group2 alternative splicing events.\n\n#' @author Andigoni Malousi\n#' @export \nfindAltSpliceDMSOverlaps <- function(bed.file.name=NULL, bed.data = NULL, known.alt.splice=NULL, group.name=\"Group\", group.thr=0.3){\n  if (is.outofbound(group.thr, 0, 1)) {stop(\"Valid grouping thresholds (0,1). Try again.\")}\n  if (is.null(bed.file.name)) {if (is.null(bed.data)) {stop(\"Neither bed.file.name nor bed.data is set.\")} } else {\n    bed.data <- read.csv(bed.file.name, sep=\",\")\n  } \n  if (is.null(known.alt.splice)) {\n    library(BSgenome.Hsapiens.UCSC.hg19)\n    mySession <- browserSession(\"UCSC\",url=\"http://genome-euro.ucsc.edu/cgi-bin/\")\n    genome(mySession)<-\"hg19\"\n    #trackNames(ucscTableQuery(mySession)) # get all track names from UCSC\n    message(\"Fetching knownAlt table from UCSC table browser...\")\n    known.alt <-getTable(ucscTableQuery(mySession, table=\"knownAlt\"))\n    message(\"DONE\")\n  } else {\n    len <- length(unlist(strsplit(known.alt.splice, \"\\\\.\")[[1]])) #Get the extension of the filename\n    if (strsplit(known.alt.splice, \"\\\\.\")[[1]][len] == \"gz\") { # Check if file is gzipped\n      known.alt <-read.csv(gzfile(known.alt.splice), header=FALSE, sep=\"\\t\") #If yes unzip it\n    } else {\n      known.alt <- read.csv(known.alt.splice,header=FALSE, sep=\"\\t\")\n    }\n  }\n\ncolnames(bed.data)<-c(\"chr\", \"start\",\"end\", \"strand\", \"score\")\nbed.list= splitGroup(bed.data, group.thr)\nknown.alt <- known.alt[,c(2:4,7,5)] #Select columns chrom, chromStart,chromEnd,strand, type\ncolnames(known.alt)<-c(\"chrom\",\"chromStart\",\"chromEnd\", \"strand\", \"name\")\n\n#Check if DMS is part of an alternative splicing events and report the merged lines bed + altsplice record\ng1.bed = with(bed.list[[1]], GRanges(chr, IRanges(start=start, end=end), strand=strand, score=score))\ng2.bed = with(bed.list[[2]], GRanges(chr, IRanges(start=start, end=end), strand=strand, score=score))\nalt = with(known.alt, GRanges(chrom, IRanges(start=chromStart, end=chromEnd), strand=strand, name=name))\ng1.hits = findOverlaps(g1.bed, alt, ignore.strand=FALSE, select=\"all\")\ng2.hits = findOverlaps(g2.bed, alt, ignore.strand=FALSE, select=\"all\")\ng1.merged <- cbind(as.data.frame(g1.bed[queryHits(g1.hits)]), as.data.frame(alt[subjectHits(g1.hits)]))\ng2.merged <- cbind(as.data.frame(g2.bed[queryHits(g2.hits)]), as.data.frame(alt[subjectHits(g2.hits)]))\ng1.freq <- count(g1.merged, 'name')\ncolnames(g1.freq)[2] <- \"g1.freq\"\ng2.freq <- count(g2.merged, 'name')\ncolnames(g2.freq)[2] <- \"g2.freq\"\nref.freq <- count(known.alt, 'name')\ncolnames(ref.freq)[2] <- \"ref.freq\"\ng1.freq$H.Group <- (g1.freq$g1.freq/sum(g1.freq$g1.freq))*100 \ng2.freq$L.Group <- (g2.freq$g2.freq/sum(g2.freq$g2.freq))*100\nref.freq$Ref <- (ref.freq$ref.freq/sum(ref.freq$ref.freq))*100\nbind.Freq <- merge(g1.freq,g2.freq, by = \"name\", all=TRUE)\ntotal.Freq <- merge(bind.Freq, ref.freq, by =\"name\", all=TRUE)\ntotal.Freq[is.na(total.Freq)] <- 0\nbar.data <- total.Freq[,c(1,3,5,7)]\nrow.names(bar.data) <- bar.data$name\n\nm.bar.data <- melt(bar.data, id.vars = \"name\")\nplot.subtitle = paste0(\"H.Group:\", nrow(g1.merged),\", L.Group:\", nrow(g2.merged), \", Reference (Ref):\", nrow(known.alt), \" events\")\nplot.title = paste0(group.name, \": Δβ >=\", group.thr, \" (H.Group) and Δβ <\", group.thr,  \" (L.Group)\")\nlibrary(reshape2)\nlibrary(scales)\np = ggplot(m.bar.data, aes(variable, value, fill = name)) +\n   geom_bar(stat='identity') \np = p + xlab(\"\") +\n  ylab(\"Frequency\") +\n  labs(fill=\"Alt Splicing Events\") +\n  ggtitle(bquote(atop(.(plot.title), atop(italic(.(plot.subtitle)), \"\")))) \ncols <- c(\"chr\", \"start\", \"end\", \"width\", \"strand\")\nmeth.cols <- paste0(\"meth.\", cols)\nevent.cols<- paste0(\"event.\", cols)\ncolnames(g1.merged)=colnames(g2.merged)=c(meth.cols, \"score\", event.cols, \"name\")\nresult <- list()\nresult[[1]]<-g1.merged\nresult[[2]]<-g2.merged\nresult[[3]]<-total.Freq[,c(1,2,4,6)]\nif (is.empty(g1.merged) || is.empty(g2.merged)) {\n  stop(\"No overlaps are found with reference alt splice records.\")\n}\nresult[[4]] <- p\nif (!is.empty(g1.merged)&&!is.empty(g2.merged)){\nresult[[5]]<- chisq.test(total.Freq[,c(2,4,6)], simulate.p.value = TRUE)$p.value} else {\n  result[[5]]<-\"Statistical significance cannot be defined for 0 values\"\n}\nreturn(result)\n}\n\n#' findCanonicalDMSOverlaps\n#'\n#' Detection of differentially methylated sites in hg19 canonical exons.\n#'\n#' @param bed.file.name   A bed file (full path) with the following fields: chrom, chromStart, chromEnd, strand, score\n#' @param canonical.table (optional) Full local path to the UCSC knownCanonical table. If the table is not available locally then the script will fetch it from UCSC.\n#' @param group.name Name of the group (Default: Group)\n#' @return Group1 overlapping segments A dataframe with high DMR (>=group.thr) that overlap with canonical exons (hg19)\n#' @return Group2 overlapping segments A dataframe with low DMR (<group.thr) that overlap with canonical exons (hg19)\n#' @return Events table per Group\n#' @return pvalue Statistical significance of group1, group2 in canonical exons.\n#' @author Andigoni Malousi\n#' @export \nfindCanonicalDMSOverlaps <- function(bed.file.name, canonical.table=NULL, group.name=\"Group\", group.thr=0.3){\n  #COMMENT: A DMS MAY OVERLAP TO MULTIPLE CANONICAL EXONS. RES[[1]] AND RES[[2]] GIVE ALL DMS (MULTIPLE ROWS PER CANONICAL EXON)\n  \n  if (is.outofbound(group.thr, 0, 1)) {stop(\"Valid grouping thresholds (0,1). Try again.\")}\n  if (is.na(bed.file.name)) {stop(\"The bed file with the differentially methylated sites is not set.\")} \n  library(plyr)\n  library(ggplot2)\n  if (is.null(canonical.table)) {\n    library(BSgenome.Hsapiens.UCSC.hg19)\n    mySession <- browserSession(\"UCSC\",url=\"http://genome-euro.ucsc.edu/cgi-bin/\")\n    genome(mySession)<-\"hg19\"\n    known.canonical <-getTable(ucscTableQuery(mySession, table=\"knownCanonical\"))\n  } else {\n    len <- length(unlist(strsplit(canonical.table, \"\\\\.\")[[1]])) #Get the extension of the filename\n    if (strsplit(canonical.table, \"\\\\.\")[[1]][len] == \"gz\") { # Check if file is gzipped\n      known.canonical <-read.csv(gzfile(canonical.table), header=FALSE, sep=\"\\t\") #If yes unzip it\n    } else {\n      known.canonical <- read.csv(canonical.table,header=FALSE, sep=\"\\t\")\n    }\n  }\n  bed.data <- read.csv(bed.file.name, sep=\",\")\n  colnames(bed.data)<-c(\"chr\", \"start\",\"end\", \"strand\", \"score\")\n  bed.list= splitGroup(bed.data, group.thr)\n  known.canonical <- known.canonical[,c(1:3,5,6)] #Select columns chrom, chromStart,chromEnd,transcript, protein\n  colnames(known.canonical)<-c(\"chrom\",\"chromStart\",\"chromEnd\", \"transcript\", \"protein\")\n\n  g1.bed = with(bed.list[[1]], GRanges(chr, IRanges(start=start, end=end), strand=strand, score=score))\n  g2.bed = with(bed.list[[2]], GRanges(chr, IRanges(start=start, end=end), strand=strand, score=score))\n  canon = with(known.canonical, GRanges(chrom, IRanges(start=chromStart, end=chromEnd), transcript=transcript, protein=protein))\n  g1.hits = findOverlaps(g1.bed, canon, ignore.strand=FALSE, select=\"all\")\n  g2.hits = findOverlaps(g2.bed, canon, ignore.strand=FALSE, select=\"all\")\n  g1.merged <- cbind(as.data.frame(g1.bed[queryHits(g1.hits)]), as.data.frame(canon[subjectHits(g1.hits)]))\n  g2.merged <- cbind(as.data.frame(g2.bed[queryHits(g2.hits)]), as.data.frame(canon[subjectHits(g2.hits)]))\n\n #The contingency table\n c.tbl <- matrix(c(nrow(bed.list[[1]]),nrow(bed.list[[2]]), nrow(g1.merged), nrow(g2.merged)),ncol=2,byrow=TRUE)\n colnames(c.tbl) <- c(\"Group1\",\"Group2\")\n rownames(c.tbl) <- c(\"Total\",\"Canonical\")\n  result <- list()\n  result[[1]]<-g1.merged\n  result[[2]]<-g2.merged\n  result[[3]]<-as.table(c.tbl)\n  result[[4]]<-chisq.test(c.tbl)$p.value\n  return(result)\n}\n\n\n\n",
    "created" : 1446569271386.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2694516833",
    "id" : "668B9BF6",
    "lastKnownWriteTime" : 1468996151,
    "path" : "~/Desktop/INAB/MeinteR/R/dmsAltSplice.R",
    "project_path" : "R/dmsAltSplice.R",
    "properties" : {
        "notebook_format" : "html_document"
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}